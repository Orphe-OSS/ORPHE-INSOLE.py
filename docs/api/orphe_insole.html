<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>orphe_insole API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orphe_insole</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="orphe_insole.to_timestamp"><code class="name flex">
<span>def <span class="ident">to_timestamp</span></span>(<span>hours, minutes, seconds, ms_high, ms_low)</span>
</code></dt>
<dd>
<div class="desc"><p>v3のデータについてくるタイムスタンプをフォーマットする関数</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hours</code></strong></dt>
<dd>時</dd>
<dt><strong><code>minutes</code></strong></dt>
<dd>分</dd>
<dt><strong><code>seconds</code></strong></dt>
<dd>秒</dd>
<dt><strong><code>ms_high</code></strong></dt>
<dd>ミリ秒の上位バイト</dd>
<dt><strong><code>ms_low</code></strong></dt>
<dd>ミリ秒の下位バイト</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orphe_insole.AccData"><code class="flex name class">
<span>class <span class="ident">AccData</span></span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>x軸の加速度</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y軸の加速度</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z軸の加速度</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccData:
    &#34;&#34;&#34;
    加速度センサの値を格納するクラス

    Attributes:
        x: x軸の加速度
        y: y軸の加速度
        z: z軸の加速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0

    def print(self):
        print(
            f&#34;Acc[{self.serial_number}][{self.packet_number}][{self.timestamp}]: {self.x}, {self.y}, {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.AccData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.DeviceInformation"><code class="flex name class">
<span>class <span class="ident">DeviceInformation</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>デバイス情報を格納するクラス
data: 生データ
battery: バッテリー残量
mount_position: マウント位置
bit0 : 左右
bit1 : 0(足底) / 1(足背)
足底 : 左、右：0=(0000 0000b), 1=(0000 0001b)、
足背 : 左、右：2(=0000 0010b), 3(=0000 0011b)
range: レンジ
加速度レンジ（ 2, 4, 8, 16(g)：0, 1, 2, 3）
ジャイロレンジ（250, 500, 1000, 2000(°/s)：0, 1, 2, 3）
version: ファームウェアバージョン
device_information: 取得したデバイス情報の保管用メンバ変数</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeviceInformation:
    &#34;&#34;&#34;
    デバイス情報を格納するクラス
    data: 生データ
    battery: バッテリー残量
    mount_position: マウント位置
        bit0 : 左右
        bit1 : 0(足底) / 1(足背)
        足底 : 左、右：0=(0000 0000b), 1=(0000 0001b)、
        足背 : 左、右：2(=0000 0010b), 3(=0000 0011b)
    range: レンジ
        加速度レンジ（ 2, 4, 8, 16(g)：0, 1, 2, 3）
        ジャイロレンジ（250, 500, 1000, 2000(°/s)：0, 1, 2, 3）
    version: ファームウェアバージョン
    device_information: 取得したデバイス情報の保管用メンバ変数
    &#34;&#34;&#34;

    def __init__(self, data):
        self.data = data
        self.battery = int.from_bytes(data[0:1], byteorder=&#39;big&#39;, signed=False)
        self.mount_position = int.from_bytes(
            data[1:2], byteorder=&#39;big&#39;, signed=False)
        self.range = Range()
        self.range.acc = int.from_bytes(
            data[8:9], byteorder=&#39;big&#39;, signed=False)
        self.range.gyro = int.from_bytes(
            data[9:10], byteorder=&#39;big&#39;, signed=False)
        self.version = int.from_bytes(
            data[18:19], byteorder=&#39;big&#39;, signed=False)
        self.device_information = None</code></pre>
</details>
</dd>
<dt id="orphe_insole.GaitData"><code class="flex name class">
<span>class <span class="ident">GaitData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>歩行解析の値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>gait_type</code></strong></dt>
<dd>歩容タイプ（0:無し、1:歩行、2:走行,3:直立静止）</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>ストライド方向（0:なし, 1:前方, 2:後方,3:内側,4:外側）</dd>
<dt><strong><code>calorie</code></strong></dt>
<dd>総消費カロリー</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>総移動距離</dd>
<dt><strong><code>standing_phase_duration</code></strong></dt>
<dd>立脚期継続時間</dd>
<dt><strong><code>swing_phase_duration</code></strong></dt>
<dd>遊脚期継続時間</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GaitData:
    &#34;&#34;&#34;
    歩行解析の値を格納するクラス

    Attributes:
        step_count: 歩数
        gait_type: 歩容タイプ（0:無し、1:歩行、2:走行,3:直立静止）
        direction: ストライド方向（0:なし, 1:前方, 2:後方,3:内側,4:外側）
        calorie: 総消費カロリー
        distance: 総移動距離
        standing_phase_duration: 立脚期継続時間
        swing_phase_duration: 遊脚期継続時間
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4番目は最初の2ビット分が enumで歩容タイプ（0:無し、1:歩行、2:走行,3:直立静止）
        self.gait_type = data[4] &amp; 0b11000000 &gt;&gt; 6
        # 4番目は2,3,4ビット分がenumでストライド方向（0:なし, 1:前方, 2:後方,3:内側,4:外側）
        self.direction = (data[4] &amp; 0b00111000) &gt;&gt; 3
        # data[6],data[7]はfloat16で総消費カロリー
        self.calorie = struct.unpack(&#39;&gt;e&#39;, data[6:8])
        # 8,9,10,11はfloat32で総移動距離
        self.distance = struct.unpack(&#39;&gt;f&#39;, data[8:12])
        # 12,13,14,15はfloat32で立脚期継続時間（standing phase duration）
        self.standing_phase_duration = struct.unpack(&#39;&gt;f&#39;, data[12:16])
        # 16,17,18,19はflaot32で遊脚期継続時間（swing_phase_duration)
        self.swing_phase_duration = struct.unpack(&#39;&gt;f&#39;, data[16:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Gait type: {self.gait_type}&#34;)
        print(f&#34;Direction: {self.direction}&#34;)
        print(f&#34;Calorie: {self.calorie}&#34;)
        print(f&#34;Distance: {self.distance}&#34;)
        print(f&#34;Standing phase duration: {self.standing_phase_duration}&#34;)
        print(f&#34;Swing phase duration: {self.swing_phase_duration}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.GaitData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.GyroData"><code class="flex name class">
<span>class <span class="ident">GyroData</span></span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>x軸の角速度</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y軸の角速度</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z軸の角速度</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GyroData:
    &#34;&#34;&#34;
    ジャイロセンサの値を格納するクラス

    Attributes:
        x: x軸の角速度
        y: y軸の角速度
        z: z軸の角速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0

    def print(self):
        print(
            f&#34;Gyro[{self.serial_number}][{self.packet_number}][{self.timestamp}]: {self.x}, {self.y}, {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.GyroData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.Orphe"><code class="flex name class">
<span>class <span class="ident">Orphe</span></span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのBLE通信を行うクラス</p>
<p>コンストラクタ</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orphe:

    &#34;&#34;&#34;
    ORPHE COREのBLE通信を行うクラス
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        コンストラクタ
        &#34;&#34;&#34;
        self.serial_number_prev = 0
        self.client = None
        self.step_count = StepCount()  # 歩数

    def set_lost_data_callback(self, callback):
        &#34;&#34;&#34;
        データが欠損したときに呼び出されるコールバック関数を設定する

        Args:
            callback: コールバック関数
        &#34;&#34;&#34;
        self.lost_data_callback = callback

    def set_got_pressure_callback(self, callback):
        &#34;&#34;&#34;
        圧力センサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_pressure_callback = callback

    def set_got_acc_callback(self, callback):
        &#34;&#34;&#34;加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。

        例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。
        &#34;&#34;&#34;
        self.got_acc_callback = callback

    def set_got_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_gyro_callback = callback

    def set_got_converted_acc_callback(self, callback):
        &#34;&#34;&#34;
        加速度センサの値を取得したときに呼び出されるコールバック関数を設定する

        それぞれの値は加速度レンジの値によって変換されます。
        例えば静止状態ではz方向の1Gの値は常に1.0です。
        &#34;&#34;&#34;
        self.got_converted_acc_callback = callback

    def set_got_converted_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_converted_gyro_callback = callback

    def set_got_quat_callback(self, callback):
        &#34;&#34;&#34;
        クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_quat_callback = callback

    def set_got_gait_callback(self, callback):
        &#34;&#34;&#34;
        歩行解析の値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_gait_callback = callback

    def set_got_stride_callback(self, callback):
        &#34;&#34;&#34;
        ストライドの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_stride_callback = callback

    def set_got_pronation_callback(self, callback):
        &#34;&#34;&#34;
        プロネーションの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_pronation_callback = callback

    def set_got_quat_distance_callback(self, callback):
        &#34;&#34;&#34;
        クォータニオンと差分値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_quat_distance_callback = callback

    def set_on_disconnect_callback(self, callback):
        &#34;&#34;&#34;
        ORPHE COREとの接続が切断されたときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.on_disconnect_callback = callback

    async def scan_all_devices(self):
        &#34;&#34;&#34;
        すべてのBLEデバイスをスキャンして、その結果を返す

        Returns:
            BLEデバイスのリスト
        &#34;&#34;&#34;
        print(&#34;Scanning all BLE devices...&#34;)
        devices = await BleakScanner.discover()
        return devices

    async def connect(self, address=None):
        &#34;&#34;&#34;
        ORPHE COREと接続する

        Args:
            address: 接続するデバイスのアドレス。指定しない場合はスキャンしてSERVICE UUIDで合致するものに接続する
        Returns:
            接続に成功した場合はTrue、失敗した場合はFalse
        &#34;&#34;&#34;
        print(
            f&#34;Scanning for ORPHE CORE BLE device...[address specified: {address}]&#34;)
        devices = await BleakScanner.discover()

        target_device = None

        if address is not None:
            for device in devices:
                if device.address == address:
                    target_device = device
                    print(
                        f&#34;Found target device: {device.name}(name), {device.address}(address)&#34;)
                    break
        else:
            for device in devices:
                #  device.name に INS* が含まれている場合に接続する
                if device.name is not None and &#34;INS&#34; in device.name:
                    target_device = device
                    print(
                        f&#34;Found target device: {device.name}(name), {device.address}(address)&#34;)
                    break

        if target_device is None:
            print(&#34;Target device not found.&#34;)
            return False

        self.client = BleakClient(target_device.address)
        await self.client.connect()
        if self.client.is_connected:
            print(&#34;Connected to the device&#34;)

            # 別のタスクで接続状態を監視
            asyncio.create_task(self.monitor_connection(self.client))

            return True
        else:
            print(&#34;Failed to connect to the device&#34;)
            return False

    async def monitor_connection(self, client):
        while True:
            await asyncio.sleep(1)  # 1秒ごとに接続状態をチェック
            if not client.is_connected:
                await self.disconnect_callback(self)
                break

    async def disconnect_callback(self, owner):
        # コールバック関数が設定されている場合、コールバック関数を呼び出す
        if hasattr(owner, &#39;on_disconnect_callback&#39;) and owner.on_disconnect_callback:
            owner.on_disconnect_callback()

    def is_connected(self):
        &#34;&#34;&#34;
        ORPHE COREに接続されているかどうかを返す

        Returns:
            接続されている場合はTrue、されていない場合はFalse
        &#34;&#34;&#34;
        if self.client is None:
            return False
        return self.client.is_connected

    async def read_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
        Returns: DeviceInformationクラスのインスタンス
        &#34;&#34;&#34;
        di = await self.client.read_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID)
        di = DeviceInformation(di)
        self.device_information = di  # デバイス情報をメンバ変数として保存（更新）しておく
        return di

    async def print_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途
        &#34;&#34;&#34;
        di = await self.read_device_information()
        print(f&#34;Version: {di.version}&#34;)
        print(f&#34;Battery: {di.battery}&#34;)
        print(f&#34;Mount Position: {di.mount_position}&#34;)
        print(f&#34;ACC Range: {di.range.acc}&#34;)
        print(f&#34;GYRO Range: {di.range.gyro}&#34;)
        # print(f&#34;Raw Data: {list(self.device_information.data)}&#34;)

    async def set_mount_position(self, mount_position):
        &#34;&#34;&#34;
        mount_position(int): 0 or 1
        Returns: None
        &#34;&#34;&#34;
        # mount_positionの値の範囲をチェック
        if mount_position &lt; 0 or mount_position &gt; 3:
            print(&#34;mount_position must be 0, 1, 2, 3.&#34;)
            return

        di = await self.read_device_information()
        di.mount_position = mount_position
        await self.write_device_information()

    async def getChecksum(self, data):
        &#34;&#34;&#34;
        デバイス情報のチェックサムを計算する
        &#34;&#34;&#34;
        checksum = 0
        for i in range(0, 19):
            checksum += data[i]
        checksum = checksum &amp; 0xFF
        return checksum

    async def right_dec2hex(self, value):
        &#34;&#34;&#34;
        10進数を16進数に変換し、右から2桁を返す
        &#34;&#34;&#34;
        # 16進数(大文字)で4桁ゼロ埋め
        hex_str = format(value, &#39;04X&#39;)
        # 右2文字を返す
        return hex_str[-2:]

    async def write_device_information(self):
        &#34;&#34;&#34;
        this.device_information に設定されている内容をORPHE INSOLEに書き込む。
        書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ
        &#34;&#34;&#34;
        if self.device_information is None:
            print(&#34;Device information is not set, Please read device information first.&#34;)
            return

        ba_write = bytearray([
            0x09,
            self.device_information.mount_position,
            0x00,
            0x00,
            0x01,
            0x00,
            0x3C,
            self.device_information.range.acc,
            self.device_information.range.gyro,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            self.device_information.version,
        ])

        checksum = await self.getChecksum(ba_write)
        checksum_hex = await self.right_dec2hex(checksum)
        ba_write = ba_write + bytearray([checksum])  # 19バイト目にチェックサムを設定

        print(f&#34;data: {list(ba_write)}, size: {len(ba_write)}&#34;)
        print(f&#34;checksum: {checksum}, hex: {checksum_hex}&#34;)

        await self.client.write_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID, ba_write)

        # 100ms待つ（これがないと即座にdevice informationを読み込まれると正しいデータ取得ができないため）
        await asyncio.sleep(WRITE_WAIT_INTERVAL_SEC)

    async def set_acc_range(self, acc_range):
        &#34;&#34;&#34;
        acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if acc_range != 2 and acc_range != 4 and acc_range != 8 and acc_range != 16:
            print(&#34;acc_range must be 2, 4, 8, or 16[g].&#34;)
            return

        # acc_range を 0,1,2,3 に変換
        acc_range = [2, 4, 8, 16].index(acc_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.acc = acc_range

        # デバイス情報を書き込む
        await self.write_device_information()

    async def set_data_streaming_mode(self, mode=4):
        &#34;&#34;&#34;
        データストリーミングモードを設定する

        mode(int): 1,3,4 のいずれか
            0x0D,0x01：リアルタイムデータを取得（従来の200Hzデータ形式）
            0x0D,0x03: リアルタイム（ジャイロ、加速度、圧力）200Hz
            0x0D,0x04: リアルタイム（ジャイロ、加速度、圧力、クオータニオン）100Hz -- デフォルト
        Returns: None
        &#34;&#34;&#34;
        if mode != 1 and mode != 3 and mode != 4:
            print(&#34;mode must be 1, 3, or 4.&#34;)
            return
        ba_write = bytearray([0x0D, mode])
        await self.client.write_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID, ba_write)
        # 指定ms待つ（これがないと即座にdevice informationを読み込まれると正しいデータ取得ができないため）
        await asyncio.sleep(WRITE_WAIT_INTERVAL_SEC)

    async def set_gyro_range(self, gyro_range):
        &#34;&#34;&#34;
        gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if gyro_range != 250 and gyro_range != 500 and gyro_range != 1000 and gyro_range != 2000:
            print(&#34;gyro_range must be 250, 500, 1000, or 2000[deg/s].&#34;)
            return

        # gyro_range を 0,1,2,3 に変換
        gyro_range = [250, 500, 1000, 2000].index(gyro_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.gyro = gyro_range

        await self.write_device_information()

    async def sensor_values_notification_handler(self, sender, data):
        &#34;&#34;&#34;
        センサの値を取得したときに呼び出されるハンドラ
        &#34;&#34;&#34;
        if (self.is_connected() == False):
            return

        # データの長さを確認
        if data[0] == 50 or data[0] == 55 or data[0] == 56:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)
            if (sensor_values.serial_number - self.serial_number_prev) &gt; 1:
                # データ欠損の場合
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(self, &#39;lost_data_callback&#39;) and self.lost_data_callback:
                    self.lost_data_callback(
                        self.serial_number_prev, sensor_values.serial_number)
            self.serial_number_prev = sensor_values.serial_number
        elif data[0] == 40:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)

    async def start_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する
        &#34;&#34;&#34;
        await self.read_device_information()
        await self.client.start_notify(CHARACTERISTIC_SENSOR_VALUES_UUID, self.sensor_values_notification_handler)

    async def step_analysis_notification_handler(self, sender, data):
        &#34;&#34;&#34;
        ステップ解析の値を取得したときに呼び出されるハンドラ
        &#34;&#34;&#34;
        # print(f&#34;Step analysis: {data[1]}&#34;)
        StepAnalysisData(self, data)

    async def start_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を開始する
        &#34;&#34;&#34;
        await self.client.start_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID, self.step_analysis_notification_handler)

    async def stop_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_SENSOR_VALUES_UUID)

    async def stop_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID)

    async def disconnect(self):
        &#34;&#34;&#34;
        ORPHE COREとの接続を切断する
        &#34;&#34;&#34;
        await self.client.disconnect()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.Orphe.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREと接続する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>接続するデバイスのアドレス。指定しない場合はスキャンしてSERVICE UUIDで合致するものに接続する</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>接続に成功した場合はTrue、失敗した場合はFalse</p></div>
</dd>
<dt id="orphe_insole.Orphe.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREとの接続を切断する</p></div>
</dd>
<dt id="orphe_insole.Orphe.disconnect_callback"><code class="name flex">
<span>async def <span class="ident">disconnect_callback</span></span>(<span>self, owner)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orphe_insole.Orphe.getChecksum"><code class="name flex">
<span>async def <span class="ident">getChecksum</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>デバイス情報のチェックサムを計算する</p></div>
</dd>
<dt id="orphe_insole.Orphe.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREに接続されているかどうかを返す</p>
<h2 id="returns">Returns</h2>
<p>接続されている場合はTrue、されていない場合はFalse</p></div>
</dd>
<dt id="orphe_insole.Orphe.monitor_connection"><code class="name flex">
<span>async def <span class="ident">monitor_connection</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orphe_insole.Orphe.print_device_information"><code class="name flex">
<span>async def <span class="ident">print_device_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途</p></div>
</dd>
<dt id="orphe_insole.Orphe.read_device_information"><code class="name flex">
<span>async def <span class="ident">read_device_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
Returns: DeviceInformationクラスのインスタンス</p></div>
</dd>
<dt id="orphe_insole.Orphe.right_dec2hex"><code class="name flex">
<span>async def <span class="ident">right_dec2hex</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>10進数を16進数に変換し、右から2桁を返す</p></div>
</dd>
<dt id="orphe_insole.Orphe.scan_all_devices"><code class="name flex">
<span>async def <span class="ident">scan_all_devices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>すべてのBLEデバイスをスキャンして、その結果を返す</p>
<h2 id="returns">Returns</h2>
<p>BLEデバイスのリスト</p></div>
</dd>
<dt id="orphe_insole.Orphe.sensor_values_notification_handler"><code class="name flex">
<span>async def <span class="ident">sensor_values_notification_handler</span></span>(<span>self, sender, data)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値を取得したときに呼び出されるハンドラ</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_acc_range"><code class="name flex">
<span>async def <span class="ident">set_acc_range</span></span>(<span>self, acc_range)</span>
</code></dt>
<dd>
<div class="desc"><p>acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
Returns: None</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_data_streaming_mode"><code class="name flex">
<span>async def <span class="ident">set_data_streaming_mode</span></span>(<span>self, mode=4)</span>
</code></dt>
<dd>
<div class="desc"><p>データストリーミングモードを設定する</p>
<p>mode(int): 1,3,4 のいずれか
0x0D,0x01：リアルタイムデータを取得（従来の200Hzデータ形式）
0x0D,0x03: リアルタイム（ジャイロ、加速度、圧力）200Hz
0x0D,0x04: リアルタイム（ジャイロ、加速度、圧力、クオータニオン）100Hz &ndash; デフォルト
Returns: None</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_acc_callback"><code class="name flex">
<span>def <span class="ident">set_got_acc_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。</p>
<p>例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_converted_acc_callback"><code class="name flex">
<span>def <span class="ident">set_got_converted_acc_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を取得したときに呼び出されるコールバック関数を設定する</p>
<p>それぞれの値は加速度レンジの値によって変換されます。
例えば静止状態ではz方向の1Gの値は常に1.0です。</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_converted_gyro_callback"><code class="name flex">
<span>def <span class="ident">set_got_converted_gyro_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_gait_callback"><code class="name flex">
<span>def <span class="ident">set_got_gait_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>歩行解析の値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_gyro_callback"><code class="name flex">
<span>def <span class="ident">set_got_gyro_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_pressure_callback"><code class="name flex">
<span>def <span class="ident">set_got_pressure_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>圧力センサの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_pronation_callback"><code class="name flex">
<span>def <span class="ident">set_got_pronation_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>プロネーションの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_quat_callback"><code class="name flex">
<span>def <span class="ident">set_got_quat_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_quat_distance_callback"><code class="name flex">
<span>def <span class="ident">set_got_quat_distance_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンと差分値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_got_stride_callback"><code class="name flex">
<span>def <span class="ident">set_got_stride_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ストライドの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_gyro_range"><code class="name flex">
<span>async def <span class="ident">set_gyro_range</span></span>(<span>self, gyro_range)</span>
</code></dt>
<dd>
<div class="desc"><p>gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
Returns: None</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_lost_data_callback"><code class="name flex">
<span>def <span class="ident">set_lost_data_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>データが欠損したときに呼び出されるコールバック関数を設定する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callback</code></strong></dt>
<dd>コールバック関数</dd>
</dl></div>
</dd>
<dt id="orphe_insole.Orphe.set_mount_position"><code class="name flex">
<span>async def <span class="ident">set_mount_position</span></span>(<span>self, mount_position)</span>
</code></dt>
<dd>
<div class="desc"><p>mount_position(int): 0 or 1
Returns: None</p></div>
</dd>
<dt id="orphe_insole.Orphe.set_on_disconnect_callback"><code class="name flex">
<span>def <span class="ident">set_on_disconnect_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREとの接続が切断されたときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_insole.Orphe.start_sensor_values_notification"><code class="name flex">
<span>async def <span class="ident">start_sensor_values_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する</p></div>
</dd>
<dt id="orphe_insole.Orphe.start_step_analysis_notification"><code class="name flex">
<span>async def <span class="ident">start_step_analysis_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の通知を開始する</p></div>
</dd>
<dt id="orphe_insole.Orphe.step_analysis_notification_handler"><code class="name flex">
<span>async def <span class="ident">step_analysis_notification_handler</span></span>(<span>self, sender, data)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の値を取得したときに呼び出されるハンドラ</p></div>
</dd>
<dt id="orphe_insole.Orphe.stop_sensor_values_notification"><code class="name flex">
<span>async def <span class="ident">stop_sensor_values_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値の通知を停止する</p></div>
</dd>
<dt id="orphe_insole.Orphe.stop_step_analysis_notification"><code class="name flex">
<span>async def <span class="ident">stop_step_analysis_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の通知を停止する</p></div>
</dd>
<dt id="orphe_insole.Orphe.write_device_information"><code class="name flex">
<span>async def <span class="ident">write_device_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this.device_information に設定されている内容をORPHE INSOLEに書き込む。
書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ</p></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.PressureData"><code class="flex name class">
<span>class <span class="ident">PressureData</span></span>
</code></dt>
<dd>
<div class="desc"><p>圧力センサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>values[6]: センサの圧力値</dt>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PressureData:
    &#34;&#34;&#34;
    圧力センサの値を格納するクラス

    Attributes:
        values[6]: センサの圧力値
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.values = [6]*0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0

    def print(self):
        print(
            f&#34;Pressure[{self.serial_number}][{self.packet_number}][{self.timestamp}]: {self.values}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.PressureData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.PronationData"><code class="flex name class">
<span>class <span class="ident">PronationData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>プロネーションの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>landing_impact</code></strong></dt>
<dd>着地衝撃力</dd>
<dt><strong><code>x</code></strong></dt>
<dd>プロネーションX</dd>
<dt><strong><code>y</code></strong></dt>
<dd>プロネーションY</dd>
<dt><strong><code>z</code></strong></dt>
<dd>プロネーションZ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PronationData:
    &#34;&#34;&#34;
    プロネーションの値を格納するクラス

    Attributes:
        step_count: 歩数
        landing_impact: 着地衝撃力
        x: プロネーションX
        y: プロネーションY
        z: プロネーションZ
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4,5,6,7はfloat32で着地衝撃力[kgf](landing_impact)
        self.landing_impact = struct.unpack(&#39;&gt;f&#39;, data[4:8])
        # 8,9,10,11はプロネーションX[deg](x)
        self.x = struct.unpack(&#39;&gt;f&#39;, data[8:12])
        # 12,13,14,15はプロネーションY[deg](y)
        self.y = struct.unpack(&#39;&gt;f&#39;, data[12:16])
        # 16,17,18,19はプロネーションZ[deg](z)
        self.z = struct.unpack(&#39;&gt;f&#39;, data[16:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Landing impact: {self.landing_impact}&#34;)
        print(f&#34;Pronation X: {self.x}&#34;)
        print(f&#34;Pronation Y: {self.y}&#34;)
        print(f&#34;Pronation Z: {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.PronationData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.QuatData"><code class="flex name class">
<span>class <span class="ident">QuatData</span></span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>w</code></strong></dt>
<dd>w</dd>
<dt><strong><code>x</code></strong></dt>
<dd>x</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuatData:
    &#34;&#34;&#34;
    クォータニオンの値を格納するクラス

    Attributes:
        w: w
        x: x
        y: y
        z: z
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.w = 0
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0

    def print(self):
        print(
            f&#34;Quat[{self.serial_number}][{self.packet_number}][{self.timestamp}]: {self.w}, {self.x}, {self.y}, {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.QuatData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.QuatDistanceData"><code class="flex name class">
<span>class <span class="ident">QuatDistanceData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンと差分値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>phase</code></strong></dt>
<dd>歩容フェイズ</dd>
<dt><strong><code>period</code></strong></dt>
<dd>歩容ピリオド</dd>
<dt><strong><code>event</code></strong></dt>
<dd>歩容イベント</dd>
<dt><strong><code>w</code></strong></dt>
<dd>クォータニオンのw</dd>
<dt><strong><code>x</code></strong></dt>
<dd>クォータニオンのx</dd>
<dt><strong><code>y</code></strong></dt>
<dd>クォータニオンのy</dd>
<dt><strong><code>z</code></strong></dt>
<dd>クォータニオンのz</dd>
<dt><strong><code>x_distance</code></strong></dt>
<dd>加速度力算出された単位時間のx移動距離</dd>
<dt><strong><code>y_distance</code></strong></dt>
<dd>加速度力算出された単位時間のy移動距離</dd>
<dt><strong><code>z_distance</code></strong></dt>
<dd>加速度力算出された単位時間のz移動距離</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuatDistanceData:
    &#34;&#34;&#34;
    クォータニオンと差分値を格納するクラス

    Attributes:
        step_count: 歩数
        phase: 歩容フェイズ
        period: 歩容ピリオド
        event: 歩容イベント
        w: クォータニオンのw
        x: クォータニオンのx
        y: クォータニオンのy
        z: クォータニオンのz
        x_distance: 加速度力算出された単位時間のx移動距離
        y_distance: 加速度力算出された単位時間のy移動距離
        z_distance: 加速度力算出された単位時間のz移動距離
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4は01ビットがenumの歩容フェイズ（0:なし, 1:立脚期, 2:遊脚期）
        self.phase = data[4] &amp; 0b00000001
        # 4は2,3,4ビットがenumの歩容ピリオド（0:なし,1:LoadingResponse, 2:MidStance, 3:TerminalStance, 4:InitialSwing, 5:MidSwing, 6:TerminalSwing）
        self.period = (data[4] &amp; 0b00011110) &gt;&gt; 1
        # 4は5,6,7ビットがenumの歩容イベント(0:なし, 1:InitialContact, 2:FootFlat, 3:HeelRise, 4:ToeOff, 5:FeetAdjacent, 6:TibiaVertical)
        self.event = (data[4] &amp; 0b11100000) &gt;&gt; 5
        # 6,7はfloat16でクォータニオンのw
        self.w = struct.unpack(&#39;&gt;e&#39;, data[6:8])
        # 8,9はfloat16でクォータニオンのx
        self.x = struct.unpack(&#39;&gt;e&#39;, data[8:10])
        # 10,11はfloat16でクォータニオンのy
        self.y = struct.unpack(&#39;&gt;e&#39;, data[10:12])
        # 12,13はfloat16でクォータニオンのz
        self.z = struct.unpack(&#39;&gt;e&#39;, data[12:14])
        # 14,15はfloat16で加速度力算出された単位時間のx移動距離
        self.x_distance = struct.unpack(&#39;&gt;e&#39;, data[14:16])
        # 16,17はfloat16で加速度力算出された単位時間のy移動距離
        self.y_distance = struct.unpack(&#39;&gt;e&#39;, data[16:18])
        # 18,19はfloat16で加速度力算出された単位時間のz移動距離
        self.z_distance = struct.unpack(&#39;&gt;e&#39;, data[18:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Phase: {self.phase}&#34;)
        print(f&#34;Period: {self.period}&#34;)
        print(f&#34;Event: {self.event}&#34;)
        print(f&#34;Quat: {self.w}, {self.x}, {self.y}, {self.z}&#34;)
        print(
            f&#34;Distance: {self.x_distance}, {self.y_distance}, {self.z_distance}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.QuatDistanceData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_insole.Range"><code class="flex name class">
<span>class <span class="ident">Range</span></span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサとジャイロセンサのレンジを格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>acc</code></strong></dt>
<dd>加速度センサのレンジ</dd>
<dt><strong><code>gyro</code></strong></dt>
<dd>ジャイロセンサのレンジ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Range:
    &#34;&#34;&#34;
    加速度センサとジャイロセンサのレンジを格納するクラス

    Attributes:
        acc: 加速度センサのレンジ
        gyro: ジャイロセンサのレンジ
    &#34;&#34;&#34;

    def __init__(self):
        self.acc = 0
        self.gyro = 0</code></pre>
</details>
</dd>
<dt id="orphe_insole.SensorValuesData"><code class="flex name class">
<span>class <span class="ident">SensorValuesData</span></span>
<span>(</span><span>owner, data, sensor_range)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
<dt><strong><code>type</code></strong></dt>
<dd>タイプ（40の場合は50Hzのv2, 50の場合は200Hzのv3）</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>acc</code></strong></dt>
<dd>加速度センサの値</dd>
<dt><strong><code>converted_acc</code></strong></dt>
<dd>変換後の加速度センサの値</dd>
<dt><strong><code>gyro</code></strong></dt>
<dd>ジャイロセンサの値</dd>
<dt><strong><code>converted_gyro</code></strong></dt>
<dd>変換後のジャイロセンサの値</dd>
<dt><strong><code>quat</code></strong></dt>
<dd>クォータニオンの値</dd>
</dl>
<p>コンストラクタ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
<dt><strong><code>sensor_range</code></strong></dt>
<dd>加速度センサとジャイロセンサのレンジ。Rangeクラスのインスタンス</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorValuesData:
    &#34;&#34;&#34;
    センサの値を格納するクラス

    Attributes:
        owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
        data: 生データ
        type: タイプ（40の場合は50Hzのv2, 50の場合は200Hzのv3）
        serial_number: シリアルナンバー
        timestamp: タイムスタンプ
        acc: 加速度センサの値
        converted_acc: 変換後の加速度センサの値
        gyro: ジャイロセンサの値
        converted_gyro: 変換後のジャイロセンサの値
        quat: クォータニオンの値
    &#34;&#34;&#34;

    def __init__(self, owner, data, sensor_range):
        &#34;&#34;&#34;
        コンストラクタ

        Args:
            owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
            data: 生データ
            sensor_range: 加速度センサとジャイロセンサのレンジ。Rangeクラスのインスタンス
            &#34;&#34;&#34;
        if data[0] == 50:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.serial_number = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = to_timestamp(
                data[3], data[4], data[5], data[6], data[7])
            each_timestamp = self.timestamp

            for i in range(3, -1, -1):
                step = 21*i
                self.acc = AccData()
                self.acc.x = int.from_bytes(
                    data[22+step:24+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.y = int.from_bytes(
                    data[24+step:26+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.z = int.from_bytes(
                    data[26+step:28+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_acc = AccData()
                amp_acc = [2, 4, 8, 16][sensor_range.acc]
                self.converted_acc.x = self.acc.x * amp_acc
                self.converted_acc.y = self.acc.y * amp_acc
                self.converted_acc.z = self.acc.z * amp_acc

                self.gyro = GyroData()
                self.gyro.x = int.from_bytes(
                    data[16+step:18+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.y = int.from_bytes(
                    data[18+step:20+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.z = int.from_bytes(
                    data[20+step:22+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_gyro = GyroData()
                amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
                self.converted_gyro.x = self.gyro.x * amp_gyro
                self.converted_gyro.y = self.gyro.y * amp_gyro
                self.converted_gyro.z = self.gyro.z * amp_gyro

                self.quat = QuatData()
                self.quat.w = int.from_bytes(
                    data[8+step:10+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.x = int.from_bytes(
                    data[10+step:12+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.y = int.from_bytes(
                    data[12+step:14+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.z = int.from_bytes(
                    data[14+step:16+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.acc.serial_number = self.serial_number
                self.converted_acc.serial_number = self.serial_number
                self.gyro.serial_number = self.serial_number
                self.converted_gyro.serial_number = self.serial_number
                self.quat.serial_number = self.serial_number
                self.acc.packet_number = 3-i
                self.converted_acc.packet_number = 3-i
                self.gyro.packet_number = 3-i
                self.converted_gyro.packet_number = 3-i
                self.quat.packet_number = 3-i

                if i == 3:
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp
                else:
                    each_timestamp = each_timestamp + data[28+step]
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp

                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_acc_callback&#39;) and owner.got_acc_callback:
                    owner.got_acc_callback(self.acc)
                if hasattr(owner, &#39;got_converted_acc_callback&#39;) and owner.got_converted_acc_callback:
                    owner.got_converted_acc_callback(self.converted_acc)
                if hasattr(owner, &#39;got_gyro_callback&#39;) and owner.got_gyro_callback:
                    owner.got_gyro_callback(self.gyro)
                if hasattr(owner, &#39;got_converted_gyro_callback&#39;) and owner.got_converted_gyro_callback:
                    owner.got_converted_gyro_callback(self.converted_gyro)
                if hasattr(owner, &#39;got_quat_callback&#39;) and owner.got_quat_callback:
                    owner.got_quat_callback(self.quat)

        # 200Hz streaming gyro accel pressure
        elif data[0] == 55:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.serial_number = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = to_timestamp(
                data[3], data[4], data[5], data[6], data[7])
            each_timestamp = self.timestamp

            for i in range(3, -1, -1):
                step = 24*i
                self.acc = AccData()
                self.acc.x = int.from_bytes(
                    data[14+step:16+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.y = int.from_bytes(
                    data[16+step:18+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.z = int.from_bytes(
                    data[18+step:20+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_acc = AccData()
                amp_acc = [2, 4, 8, 16][sensor_range.acc]
                self.converted_acc.x = self.acc.x * amp_acc
                self.converted_acc.y = self.acc.y * amp_acc
                self.converted_acc.z = self.acc.z * amp_acc

                self.gyro = GyroData()
                self.gyro.x = int.from_bytes(
                    data[8+step:10+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.y = int.from_bytes(
                    data[10+step:12+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.z = int.from_bytes(
                    data[12+step:14+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_gyro = GyroData()
                amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
                self.converted_gyro.x = self.gyro.x * amp_gyro
                self.converted_gyro.y = self.gyro.y * amp_gyro
                self.converted_gyro.z = self.gyro.z * amp_gyro

                # self.quat = QuatData()
                # self.quat.w = int.from_bytes(
                #     data[8+step:10+step], byteorder=&#39;big&#39;, signed=True) / 32768
                # self.quat.x = int.from_bytes(
                #     data[10+step:12+step], byteorder=&#39;big&#39;, signed=True) / 32768
                # self.quat.y = int.from_bytes(
                #     data[12+step:14+step], byteorder=&#39;big&#39;, signed=True) / 32768
                # self.quat.z = int.from_bytes(
                #     data[14+step:16+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.pressure = PressureData()
                for j in range(6):
                    self.pressure.values.append(int.from_bytes(
                        data[20+step+2*j:22+step+2*j], byteorder=&#39;big&#39;, signed=False))

                self.acc.serial_number = self.serial_number
                self.converted_acc.serial_number = self.serial_number
                self.gyro.serial_number = self.serial_number
                self.converted_gyro.serial_number = self.serial_number
                # self.quat.serial_number = self.serial_number
                self.pressure.serial_number = self.serial_number
                self.acc.packet_number = 3-i
                self.converted_acc.packet_number = 3-i
                self.gyro.packet_number = 3-i
                self.converted_gyro.packet_number = 3-i
                # self.quat.packet_number = 3-i
                self.pressure.packet_number = 3-i

                if i == 3:
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    # self.quat.timestamp = each_timestamp
                    self.pressure.timestamp = each_timestamp
                else:
                    each_timestamp = each_timestamp + data[28+step]
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    # self.quat.timestamp = each_timestamp
                    self.pressure.timestamp = each_timestamp

                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_acc_callback&#39;) and owner.got_acc_callback:
                    owner.got_acc_callback(self.acc)
                if hasattr(owner, &#39;got_converted_acc_callback&#39;) and owner.got_converted_acc_callback:
                    owner.got_converted_acc_callback(self.converted_acc)
                if hasattr(owner, &#39;got_gyro_callback&#39;) and owner.got_gyro_callback:
                    owner.got_gyro_callback(self.gyro)
                if hasattr(owner, &#39;got_converted_gyro_callback&#39;) and owner.got_converted_gyro_callback:
                    owner.got_converted_gyro_callback(self.converted_gyro)
                if hasattr(owner, &#39;got_pressure_callback&#39;) and owner.got_pressure_callback:
                    owner.got_pressure_callback(self.pressure)
                # if hasattr(owner, &#39;got_quat_callback&#39;) and owner.got_quat_callback:
                #     owner.got_quat_callback(self.quat)
         # 100Hz streaming gyro accel pressure quaternion
        # 100Hz streaming gyro accel pressure quaternion
        elif data[0] == 56:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.serial_number = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = to_timestamp(
                data[3], data[4], data[5], data[6], data[7])
            each_timestamp = self.timestamp

            for i in range(1, -1, -1):
                step = 32*i
                self.acc = AccData()
                self.acc.x = int.from_bytes(
                    data[22+step:24+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.y = int.from_bytes(
                    data[24+step:26+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.z = int.from_bytes(
                    data[26+step:28+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_acc = AccData()
                amp_acc = [2, 4, 8, 16][sensor_range.acc]
                self.converted_acc.x = self.acc.x * amp_acc
                self.converted_acc.y = self.acc.y * amp_acc
                self.converted_acc.z = self.acc.z * amp_acc

                self.gyro = GyroData()
                self.gyro.x = int.from_bytes(
                    data[16+step:18+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.y = int.from_bytes(
                    data[18+step:20+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.z = int.from_bytes(
                    data[20+step:22+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_gyro = GyroData()
                amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
                self.converted_gyro.x = self.gyro.x * amp_gyro
                self.converted_gyro.y = self.gyro.y * amp_gyro
                self.converted_gyro.z = self.gyro.z * amp_gyro

                self.quat = QuatData()
                self.quat.w = int.from_bytes(
                    data[8+step:10+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.x = int.from_bytes(
                    data[10+step:12+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.y = int.from_bytes(
                    data[12+step:14+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.z = int.from_bytes(
                    data[14+step:16+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.pressure = PressureData()
                for j in range(6):
                    self.pressure.values.append(int.from_bytes(
                        data[28+step+2*j:30+step+2*j], byteorder=&#39;big&#39;, signed=False))

                self.acc.serial_number = self.serial_number
                self.converted_acc.serial_number = self.serial_number
                self.gyro.serial_number = self.serial_number
                self.converted_gyro.serial_number = self.serial_number
                self.quat.serial_number = self.serial_number
                self.pressure.serial_number = self.serial_number
                self.acc.packet_number = 1-i
                self.converted_acc.packet_number = 1-i
                self.gyro.packet_number = 1-i
                self.converted_gyro.packet_number = 1-i
                self.quat.packet_number = 1-i
                self.pressure.packet_number = 1-i

                self.acc.timestamp = each_timestamp
                self.converted_acc.timestamp = each_timestamp
                self.gyro.timestamp = each_timestamp
                self.converted_gyro.timestamp = each_timestamp
                self.quat.timestamp = each_timestamp
                self.pressure.timestamp = each_timestamp

                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_acc_callback&#39;) and owner.got_acc_callback:
                    owner.got_acc_callback(self.acc)
                if hasattr(owner, &#39;got_converted_acc_callback&#39;) and owner.got_converted_acc_callback:
                    owner.got_converted_acc_callback(self.converted_acc)
                if hasattr(owner, &#39;got_gyro_callback&#39;) and owner.got_gyro_callback:
                    owner.got_gyro_callback(self.gyro)
                if hasattr(owner, &#39;got_converted_gyro_callback&#39;) and owner.got_converted_gyro_callback:
                    owner.got_converted_gyro_callback(self.converted_gyro)
                if hasattr(owner, &#39;got_pressure_callback&#39;) and owner.got_pressure_callback:
                    owner.got_pressure_callback(self.pressure)
                if hasattr(owner, &#39;got_quat_callback&#39;) and owner.got_quat_callback:
                    owner.got_quat_callback(self.quat)</code></pre>
</details>
</dd>
<dt id="orphe_insole.StepAnalysisData"><code class="flex name class">
<span>class <span class="ident">StepAnalysisData</span></span>
<span>(</span><span>owner, data)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の値を格納するクラス</p>
<p>コンストラクタ</p>
<p>data[1]のサブヘッダによって解析データの種類がわかる。対応するのは、0,1,2,3,4 である。また、0,1,2,3 に関してはデータ到着担保のために同じデータが二回連続で送信されてくるため、歩数カウントで更新すべきデータかどうかを判断する必要がある。</p>
<p>0: Gait Overview
1: Stride
2: Pronation
3: 未実装
4: クオータニオン
5: 未実装
6: 未実装</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（StepAnalysisDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StepAnalysisData:
    &#34;&#34;&#34;
    ステップ解析の値を格納するクラス
    &#34;&#34;&#34;

    def __init__(self, owner, data):
        &#34;&#34;&#34;
        コンストラクタ

        data[1]のサブヘッダによって解析データの種類がわかる。対応するのは、0,1,2,3,4 である。また、0,1,2,3 に関してはデータ到着担保のために同じデータが二回連続で送信されてくるため、歩数カウントで更新すべきデータかどうかを判断する必要がある。

        0: Gait Overview
        1: Stride
        2: Pronation
        3: 未実装
        4: クオータニオン
        5: 未実装
        6: 未実装

        Args:
            owner: オーナー（StepAnalysisDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
            data: 生データ
        &#34;&#34;&#34;
        self.data = data

        # gait overview
        if data[1] == 0:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            if self.step_count &gt; owner.step_count.gait:
                self.gait = GaitData(data)
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_gait_callback&#39;) and owner.got_gait_callback:
                    owner.got_gait_callback(self.gait)
            owner.step_count.gait = self.step_count
        # stride
        elif data[1] == 1:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            if self.step_count &gt; owner.step_count.stride:
                self.stride = StrideData(data)
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_stride_callback&#39;) and owner.got_stride_callback:
                    owner.got_stride_callback(self.stride)
            owner.step_count.stride = self.step_count
        # pronation
        elif data[1] == 2:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            if self.step_count &gt; owner.step_count.pronation:
                self.pronation = PronationData(data)
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_pronation_callback&#39;) and owner.got_pronation_callback:
                    owner.got_pronation_callback(self.pronation)
            owner.step_count.pronation = self.step_count
        # quaternion
        elif data[1] == 4:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            # if self.step_count &gt; owner.step_count.quat:
            self.quat_distance = QuatDistanceData(data)
            # コールバック関数が設定されている場合、コールバック関数を呼び出す
            if hasattr(owner, &#39;got_quat_distance_callback&#39;) and owner.got_quat_distance_callback:
                owner.got_quat_distance_callback(self.quat_distance)
            owner.step_count.quat = self.step_count</code></pre>
</details>
</dd>
<dt id="orphe_insole.StepCount"><code class="flex name class">
<span>class <span class="ident">StepCount</span></span>
</code></dt>
<dd>
<div class="desc"><p>歩数を格納するクラス</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StepCount:
    &#34;&#34;&#34;
    歩数を格納するクラス&#34;&#34;&#34;

    def __init__(self):
        self.gait = 0
        self.stride = 0
        self.pronation = 0
        self.quat = 0</code></pre>
</details>
</dd>
<dt id="orphe_insole.StrideData"><code class="flex name class">
<span>class <span class="ident">StrideData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>ストライドの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>foot_angle</code></strong></dt>
<dd>フットアングル</dd>
<dt><strong><code>x</code></strong></dt>
<dd>ストライドX</dd>
<dt><strong><code>y</code></strong></dt>
<dd>ストライドY</dd>
<dt><strong><code>z</code></strong></dt>
<dd>ストライドZ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrideData:
    &#34;&#34;&#34;
    ストライドの値を格納するクラス

    Attributes:
        step_count: 歩数
        foot_angle: フットアングル
        x: ストライドX
        y: ストライドY
        z: ストライドZ
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4,5,6,7はfloat32でフットアングル
        self.foot_angle = struct.unpack(&#39;&gt;f&#39;, data[4:8])
        # 8,9,10,11はfloat32でストライドX
        self.x = struct.unpack(&#39;&gt;f&#39;, data[8:12])
        # 12,13,14,15はfloat32でストライドY
        self.y = struct.unpack(&#39;&gt;f&#39;, data[12:16])
        # 16,17,18,19はfloat32でストライドZ
        self.z = struct.unpack(&#39;&gt;f&#39;, data[16:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Foot angle: {self.foot_angle}&#34;)
        print(f&#34;Stride X: {self.x}&#34;)
        print(f&#34;Stride Y: {self.y}&#34;)
        print(f&#34;Stride Z: {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_insole.StrideData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="orphe_insole.to_timestamp" href="#orphe_insole.to_timestamp">to_timestamp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orphe_insole.AccData" href="#orphe_insole.AccData">AccData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.AccData.print" href="#orphe_insole.AccData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.DeviceInformation" href="#orphe_insole.DeviceInformation">DeviceInformation</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_insole.GaitData" href="#orphe_insole.GaitData">GaitData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.GaitData.print" href="#orphe_insole.GaitData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.GyroData" href="#orphe_insole.GyroData">GyroData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.GyroData.print" href="#orphe_insole.GyroData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.Orphe" href="#orphe_insole.Orphe">Orphe</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.Orphe.connect" href="#orphe_insole.Orphe.connect">connect</a></code></li>
<li><code><a title="orphe_insole.Orphe.disconnect" href="#orphe_insole.Orphe.disconnect">disconnect</a></code></li>
<li><code><a title="orphe_insole.Orphe.disconnect_callback" href="#orphe_insole.Orphe.disconnect_callback">disconnect_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.getChecksum" href="#orphe_insole.Orphe.getChecksum">getChecksum</a></code></li>
<li><code><a title="orphe_insole.Orphe.is_connected" href="#orphe_insole.Orphe.is_connected">is_connected</a></code></li>
<li><code><a title="orphe_insole.Orphe.monitor_connection" href="#orphe_insole.Orphe.monitor_connection">monitor_connection</a></code></li>
<li><code><a title="orphe_insole.Orphe.print_device_information" href="#orphe_insole.Orphe.print_device_information">print_device_information</a></code></li>
<li><code><a title="orphe_insole.Orphe.read_device_information" href="#orphe_insole.Orphe.read_device_information">read_device_information</a></code></li>
<li><code><a title="orphe_insole.Orphe.right_dec2hex" href="#orphe_insole.Orphe.right_dec2hex">right_dec2hex</a></code></li>
<li><code><a title="orphe_insole.Orphe.scan_all_devices" href="#orphe_insole.Orphe.scan_all_devices">scan_all_devices</a></code></li>
<li><code><a title="orphe_insole.Orphe.sensor_values_notification_handler" href="#orphe_insole.Orphe.sensor_values_notification_handler">sensor_values_notification_handler</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_acc_range" href="#orphe_insole.Orphe.set_acc_range">set_acc_range</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_data_streaming_mode" href="#orphe_insole.Orphe.set_data_streaming_mode">set_data_streaming_mode</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_acc_callback" href="#orphe_insole.Orphe.set_got_acc_callback">set_got_acc_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_converted_acc_callback" href="#orphe_insole.Orphe.set_got_converted_acc_callback">set_got_converted_acc_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_converted_gyro_callback" href="#orphe_insole.Orphe.set_got_converted_gyro_callback">set_got_converted_gyro_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_gait_callback" href="#orphe_insole.Orphe.set_got_gait_callback">set_got_gait_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_gyro_callback" href="#orphe_insole.Orphe.set_got_gyro_callback">set_got_gyro_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_pressure_callback" href="#orphe_insole.Orphe.set_got_pressure_callback">set_got_pressure_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_pronation_callback" href="#orphe_insole.Orphe.set_got_pronation_callback">set_got_pronation_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_quat_callback" href="#orphe_insole.Orphe.set_got_quat_callback">set_got_quat_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_quat_distance_callback" href="#orphe_insole.Orphe.set_got_quat_distance_callback">set_got_quat_distance_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_got_stride_callback" href="#orphe_insole.Orphe.set_got_stride_callback">set_got_stride_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_gyro_range" href="#orphe_insole.Orphe.set_gyro_range">set_gyro_range</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_lost_data_callback" href="#orphe_insole.Orphe.set_lost_data_callback">set_lost_data_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_mount_position" href="#orphe_insole.Orphe.set_mount_position">set_mount_position</a></code></li>
<li><code><a title="orphe_insole.Orphe.set_on_disconnect_callback" href="#orphe_insole.Orphe.set_on_disconnect_callback">set_on_disconnect_callback</a></code></li>
<li><code><a title="orphe_insole.Orphe.start_sensor_values_notification" href="#orphe_insole.Orphe.start_sensor_values_notification">start_sensor_values_notification</a></code></li>
<li><code><a title="orphe_insole.Orphe.start_step_analysis_notification" href="#orphe_insole.Orphe.start_step_analysis_notification">start_step_analysis_notification</a></code></li>
<li><code><a title="orphe_insole.Orphe.step_analysis_notification_handler" href="#orphe_insole.Orphe.step_analysis_notification_handler">step_analysis_notification_handler</a></code></li>
<li><code><a title="orphe_insole.Orphe.stop_sensor_values_notification" href="#orphe_insole.Orphe.stop_sensor_values_notification">stop_sensor_values_notification</a></code></li>
<li><code><a title="orphe_insole.Orphe.stop_step_analysis_notification" href="#orphe_insole.Orphe.stop_step_analysis_notification">stop_step_analysis_notification</a></code></li>
<li><code><a title="orphe_insole.Orphe.write_device_information" href="#orphe_insole.Orphe.write_device_information">write_device_information</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.PressureData" href="#orphe_insole.PressureData">PressureData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.PressureData.print" href="#orphe_insole.PressureData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.PronationData" href="#orphe_insole.PronationData">PronationData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.PronationData.print" href="#orphe_insole.PronationData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.QuatData" href="#orphe_insole.QuatData">QuatData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.QuatData.print" href="#orphe_insole.QuatData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.QuatDistanceData" href="#orphe_insole.QuatDistanceData">QuatDistanceData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.QuatDistanceData.print" href="#orphe_insole.QuatDistanceData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_insole.Range" href="#orphe_insole.Range">Range</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_insole.SensorValuesData" href="#orphe_insole.SensorValuesData">SensorValuesData</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_insole.StepAnalysisData" href="#orphe_insole.StepAnalysisData">StepAnalysisData</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_insole.StepCount" href="#orphe_insole.StepCount">StepCount</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_insole.StrideData" href="#orphe_insole.StrideData">StrideData</a></code></h4>
<ul class="">
<li><code><a title="orphe_insole.StrideData.print" href="#orphe_insole.StrideData.print">print</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
